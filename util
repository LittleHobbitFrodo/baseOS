#!/bin/bash

##	this script (hopefuly) provides simple and intuitive way to manage the project

#	NOTE: script executions starts below all the functions (about line 1000)



#	variables below are to be modified when tinkering with project components
MAIN_C_FILE=init.c		#	in ./kernel/c/src/
CONFIG_PATH="$PWD/config"
UTIL_CONFIG_FILE="$PWD/config/util.conf"
DISK_IMAGE_SIZE=128		#	in MB
OS_RELEASE_FILE=./os-release.txt
image="./files/baseOS.iso"		#	disk image file name
kernel_name="$(cat ./kernel/name)"
kernel="./files/$kernel_name.bin"



#	functions below are used to print coloured output

black() { echo -e "\033[0;30m$1\033[0m"; }
red() { echo -e "\033[0;31m$1\033[0m"; }
green() { echo -e "\033[0;32m$1\033[0m"; }
yellow() { echo -e "\033[1;33m$1\033[0m"; }
blue() { echo -e "\033[0;34m$1\033[0m"; }
magenta() { echo -e "\033[0;35m$1\033[0m"; }
cyan() { echo -e "\033[0;36m$1\033[0m"; }
white() { echo -e "\033[0m$1\033[0m"; }

error() { echo "$(red ERROR): $1"; }
note() { echo "$(magenta NOTE): $1"; }
warning() { echo "$(yellow WARNING): $1"; }
warning_no_endl() { echo -n "$(yellow WARNING): $1"; }




function build_parse_parameters() {

	#	parse parameters
	for i in $(seq 0 "${#args[@]}"); do
		if [ "${args[$i]}" == "--" ]; then
			((i++))
			local compiler_params=("${args[@]:$i}")
			break;
		else
			case "${args[$i]}" in
				"debug")
					debug=1
					note "building with debug options"
				;;
				"run")
					emulate=1
				;;
				"gdb")
					if [ "$emulate" == 0 ]; then
						error "you cannot use debugger without emulating the OS"
						subcmdargs=("build")
						help 1
					fi
					debugger=1
				;;
				"c")
					if [ "$os_lang" == "NONE" ]; then
						lang="c"
						note "setting language to C"
					else
						if [ "$os_lang" != "c" ]; then
							error "language specified in config and in commandline"
							subcmdargs=("build")
							help 1
						fi
					fi
				;;
				"rust")
					if [ "$os_lang" == "NONE" ]; then
						lang="rust"
						note "setting language to rust"
					else
						if [ "$os_lang" == "rust" ]; then
							error "language specified in config and in commandline"
							subcmdargs=("build")
							help 1
						fi
					fi
				;;
				"");;
				*)
					error "unknown command ${args[$i]}"
					subcmdargs=("build")
					help 1
				;;
			esac
		fi
	done
}


function build_find_tools() {
	#	search $PATH for compilers and linker

	IFS=":"

	debug=0
	emulate=0
	debugger=0
	args=($@)
	compiler_params=()
	compiler="NONE"
	asm_compiler="NONE"
	linker="NONE"
	kernel_name="$(cat ./kernel/name)"


	if [ "$os_arch" == "arm64" ]; then
		local arch="aarch64"
	else
		local arch="x86_64"
	fi


	#	find linker
    if [ "$(uname -m)" == "$os_arch" ]; then
      	for i in $PATH; do
       		if [ -e "$i/ld" ]; then
       			linker="$i/ld"
       			break;
       		fi
       	done
       	if [ "$linker" == "NONE" ]; then
       		error "could not find linker ($(blue ld), please install it and make sure it is in PATH"
       		return 1
    	fi
	else
       	for i in $PATH; do
       		if [ -e "$i/$arch-elf-ld" ]; then
       			linker="$i/$arch-elf-ld"
				break;
       		fi
       	done
       	if [ "$linker" == "NONE" ]; then
       		error "could not find $(blue "$arch-elf-ld"), please install it and make sure it is in PATH"
       		note "linker should be in the $(blue "$arch-elf-gcc") package"
       		return 1
       	fi
    fi
    note "using $(blue "$linker") as linker"

	#	find assembler
	for i in $PATH; do
		if [ -e "$i/nasm" ]; then
			asm_compiler="$i/nasm"
			break;
		fi
	done
	if [ "$asm_compiler" == "NONE" ]; then
		error "could not find assembler"
		echo "please install the $(blue nasm) assembler and make sure its in PATH"
		return 1
	fi
	note "using $(blue "$asm_compiler") as assembler"


	#	find compiler
	if [ "$lang" == "c" ]; then
		#	C
		if [ "$(uname -m)" == "$os_arch" ]; then
			for i in $PATH; do
				if [ -e "$i/gcc" ]; then
					compiler="$i/gcc"
					break;
				fi
			done
		else
			note "you are not on native platform, cross-compiler will be used"

			for i in $PATH; do
				if [ -e "$i/$arch-elf-gcc" ]; then
					compiler="$i/$arch-elf-gcc"
					break;
				fi
			done

			if [ "$compiler" == "NONE" ]; then
				error "could not find the $(red "$arch-elf-gcc"), please install it and make sure its in PATH"
				return 1
			fi
		fi

		if [ "$compiler" == "NONE" ]; then
        	error "could not find C compiler ($(blue gcc), please install it and make sure its in PATH"
        	return 1
        fi
        note "using $(blue "$compiler") as C compiler"
	else
		#	rust
		for i in $PATH; do
			if [ -e "$i/rustc" ]; then
				compiler="$i/rustc"
				break;
			fi
		done

		if [ "$compiler" == "NONE" ]; then
        	error "could not find $(blue rust), please install it and make sure its in PATH"
        	return 1
        fi
        note "using $(blue "$compiler") as rust compiler"
	fi
}


function compile_c() {
	if [ "$os_arch" == "x86_64" ]; then
		local arch="x86-64"
	else
		local arch="aarch64"
	fi

	local compiler_params=("-I$PWD/kernel/" "-ffreestanding" "-fPIE" "-nostdlib" "-nostartfiles" "-mgeneral-regs-only"
	"-march=$arch" "-Wall" "-Wextra" "-DKERNEL_NAME=$(cat ./kernel/name)" "-DKERNEL_VERSION=$(cat ./kernel/version)"
	"-DOS_NAME=$os_name" "-DOS_VERSION=os_version" "-DOS_RELEASE=$os_release" "-fno-exceptions" "-m64" "-c")

	if [ "$debug" == 0 ]; then
		local additional_params=("-finline-functions" "-O3" "-llibrary")
	else
		local additional_params=("-fno-inline" "-g" "-O1" "-fno-omit-frame-pointer" "-DKERNEL_DEBUG")
	fi

	output="$($compiler "${compiler_params[@]}" "${additional_params[@]}" "$path/src/$MAIN_C_FILE" -o ./tmp/kernel/kernel.o)"

	if [ "$?" != 0 ]; then
		error "kernel compilation failed"
		echo compiler output:
		echo $output
		if [ "$(echo $output | wc -c)" -gt 1000 ]; then
			echo $output > output.txt
			note "compiler output was put to output.txt file"
		fi
		return 1
	fi

}

function compile_rust() {
	cd $path

	output="$(cargo build --release --target-dir bin --verbose --target $os_arch-unknown-none)"
	if [ "$?" != 0 ]; then
	error "failed to build kernel"
	echo compiler output:
	echo $output
	if [ "$(echo $output | wc -c)" -gt 1000 ]; then
		echo $output > output.txt
		note "compiler output was put to output.txt file"
	fi
	return 1; 
	fi

	cp $PWD/bin/$os_arch-unknown-none/release/baseOS $PWD/$go_back/tmp/kernel/kernel.o
	if [ "$?" != 0 ]; then error "failed to copy kernel"; return 1; fi

	cd $go_back

}


function compile_asm() {
	#	compile assembly

    local asmfiles="$(find "$path" -name "*.asm")"
    for i in $asmfiles; do
    	local bname="$(basename $i)"
    	local bname="${bname/.asm/.o}"


    	if [ "$debug" == 0 ]; then
    		output="$($asm_compiler -f elf64 -o "./tmp/kernel/$bname" $i)"
    	else
			output="$($asm_compiler -f elf64 -g dwarf -o "./tmp/kernel/$bname" $i)"
    	fi
    	if [ "$?" != 0 ]; then
    		error "file $i failed to compile"
			echo compiler output:
			echo $output
    		return 1
    	fi
    done
}

function mkiso() {

	limine="./bootloader/limine/limine-$(uname)-$(uname -m)"		#	platform dependent binary
	path_limine="$(pwd)/bootloader"

	if [ ! -e "$kernel" ]; then
		error "kernel binary does not exist"
		return 1
	fi

	if [ ! -e "./iso" ]; then
		output="$(mkdir -p ./iso/EFI ./iso/EFI/BOOT ./iso/boot ./iso/boot/limine)"
		if [ "$?" != 0 ]; then
			error "unable to create directory structure for ISO creation"
			echo "command output: $output"
			return 1
		fi
	fi

	output="$(cp $kernel ./iso/boot/)"
	if [ "$?" != 0 ]; then
		error "failed to copy kernel"
		echo "output: $output"
		return 1
	fi

	if [ "$debug" == 1 ]; then
		local config="$path_limine/configs/limine-debug.conf"
	else
		local config="$path_limine/configs/limine.conf"
	fi

	output="$(cp $config $path_limine/limine-bios.sys ./iso/boot/limine)"
	if [ "$?" != 0 ]; then
		error "failed to copy bootloader config"
		echo "output: $output"
		return 1
	fi

	output="$(cp $path_limine/BOOTX64.EFI ./iso/EFI/BOOT)"
	if [ "$?" != 0 ]; then
		error "failed to copy BOOTX64.EFI"
		echo "output: $output"
		return 1
	fi

	#	place limine CDs into the iso
	output="$(cp ./bootloader/limine-bios-cd.bin ./bootloader/limine-uefi-cd.bin ./iso)"
	if [ "$?" != 0 ]; then
		error "failed to copy limine CDs"
		echo "output: $output"
		return 1
	fi


	#	create iso
	output="$(xorriso -as mkisofs -R -r -J -b limine-bios-cd.bin\
	-no-emul-boot -boot-load-size 4 -boot-info-table -hfsplus -apm-block-size 2048\
	--efi-boot limine-uefi-cd.bin -efi-boot-part --efi-boot-image\
	--protective-msdos-label $PWD/iso -o $image)"
	if [ "$?" != 0 ]; then
		error "failed to create iso"
		echo "output: $output"
		return 1
	fi

	#	install limine
	output="$($limine bios-install $image)"
	if [ "$?" != 0 ]; then
	 	error "failed to install bootloader"
	 	echo limine output:
	 	echo $output
	 	return 1
	fi

	note "ISO create successfully"

	return 0






#	old code (too scared to remove it)

	# #	create file
	# dd if=/dev/zero "of=$image" bs=1M count=0 "seek=$DISK_IMAGE_SIZE" > /dev/null 2>&1
	# if [ "$?" != 0 ]; then error "failed to create disk image"; return 1; fi

	# #	manage disk image
	# output="$(parted "$image" mklabel gpt)"
	# if [ "$?" != 0 ]; then
	# 	error "failed to create GPT"
	# 	echo command output:
	# 	echo $output
	# 	return 1
	# fi

	# output="$(parted "$image" mkpart primary 2048s $DISK_IMAGE_SIZE)"
	# if [ "$?" != 0 ]; then
	# 	error "failed to create partition"
	# 	echo command output:
	# 	echo $output
	# 	return 1
	# fi

	# output="$(parted "$image" set 1 esp on)"
	# if [ "$?" != 0 ]; then
	# 	error "failed to set ESP on"
	# 	echo command output:
	# 	echo $output
	# 	return 1
	# fi

	# if [ ! -e "$image" ]; then
	# 	cp ./files/.template-img.img "$image"
	# 	if [ "$?" != 0 ]; then
	# 		error "failed to copy template disk image"
	# 		echo command output:
	# 		echo $output
	# 		return 1
	# 	fi
	# fi


	# #	install limine
	# output="$($limine bios-install $image)"
	# if [ "$?" != 0 ]; then
	# 	error "failed to install bootloader"
	# 	echo limine output:
	# 	echo $output
	# 	return 1
	# fi

	# output="$(mformat -i "$image@@1M")"
	# if [ "$?" != 0 ]; then
	# 	error "failed to format device"
	# 	echo command output:
	# 	echo $output
	# 	return 1
	# fi

	# #	create subdirs
	# output="$(mmd -i "$image@@1M" ::/EFI ::/EFI/BOOT ::/boot ::/boot/limine)"
	# if [ "$?" != 0 ]; then
	# 	error "failed to create subdirectories"
	# 	echo command output:
	# 	echo $output
	# 	return 1
	# fi

	# #	copy kernel
	# output="$(mcopy -i "$image@@1M" "$kernel" ::/boot)"
	# if [ "$?" != 0 ]; then
	# 	error "failed to copy kernel"
	# 	echo command output:
	# 	echo $output
	# 	return 1
	# fi


	# #	copy bl config
	# if [ "$debug" == 1 ]; then
	# 	local config="$path_limine/configs/limine-debug.conf"
	# else
	# 	local config="$path_limine/configs/limine.conf"
	# fi

	# output="$(mcopy -i "$image@@1M" $config $path_limine/limine-bios.sys ::/boot/limine)"
	# if [ "$?" != 0 ]; then
	# 	error "failed to copy bootloader configuration"
	# 	echo command output:
	# 	echo $output
	# 	return 1
	# fi


	# output="$(mcopy -i "$image@@1M" $path_limine/BOOTX64.EFI ::/EFI/BOOT)"
	# if [ "$?" != 0 ]; then
	# 	error "failed to copy bootloader entrypoint"
	# 	echo command output:
	# 	echo $output
	# 	return 1
	# fi


	# note "disk image generation completed"


	return 0
}

function build() {

	local lang=$os_lang

	build_parse_parameters
	if [ "$?" != 0 ]; then error "failed to parse parameters for $(blue build) subcommand"; return 1; fi

	build_find_tools
	if [ "$?" != 0 ]; then
		local unpresent_tools=()
		if [ "$linker" == "NONE" ]; then
			unpresent_tools+=("linker")
		fi
		if [ "$compiler" == "NONE" ]; then
			unpresent_tools+=("compiler")
		fi
		error "unable to find $unpresent_tools"
	fi



	#	create directories for object files
	if [ -e "./tmp/kernel/" ]; then
		rm -rf ./tmp/kernel/*
	else
		mkdir -p ./tmp/kernel/
	fi


	#	compile kernel
	if [ "$lang" == "c" ]; then
		compile_c
	else
		compile_rust
	fi
	if [ "$?" != 0 ]; then error "unable to compile the main part of the kernel"; return 1; fi

	compile_asm
	if [ "$?" != 0 ]; then error "failed to compile assembly file(s)"; return 1; fi

	#	link files together
    rm -rf ./files/*
	if [ "$os_lang" == "rust" ]; then
          	cp ./tmp/kernel/kernel.o "$kernel"
       fi



	#	link files together
	if [ "$os_lang" != "rust" ]; then
    	find "./tmp/kernel" -name "*.o" -print0 | xargs -0 $linker -m "elf_$os_arch" -nostdlib -static --no-dynamic-linker -z text -z max-page-size=0x1000 -T "$PWD/kernel/linker.ld" -o "$kernel"
		if [ "$?" != 0 ]; then error "failed to link files"; return 1; fi
	fi
	note "kernel compilation succeeded"


	mkiso
	if [ "$?" != 0 ]; then error "failed to create disk image"; return 1; fi

	if [ $emulate -eq 1 ]; then
		if [ "$debugger" != 0 ]; then
			subcmdargs=("gdb")
		else
			subcmdargs=()
		fi
		run
	fi


	return 0
}





function test() {
	echo test
	return 0
}






function run() {
	local debugger=0
	IFS=:
	for i in "${subcmdargs[@]}"; do
		case "$i" in
			"gdb")
				local debugger=1
			;;
			*)
				error "unknown token '$(red "$i")' for $(blue run)"
				return 1
			;;
		esac
	done

	if [ -e "$CONFIG_PATH/qemu-parameters" ]; then
		local emulator_params=$(cat "$CONFIG_PATH/qemu-parameters")
	else
		local emulator_params=""
	fi

	if [ "$debugger" -eq 1 ]; then
		qemu-system-x86_64 -s -S -drive file=$image,if=virtio,media=disk,discard=unmap $emulator_params &
		gdb -ex "target remote tcp:1234" $image
	else
		qemu-system-x86_64 -drive file=$image,if=virtio,media=disk,discard=unmap $emulator_params -D io.log -d out_asm
	fi
	if [ "$?" != 0 ]; then error "emulation failed"; return 1; fi
}




function dependencies() {

	local all=0

	IFS=:
	for i in "${subcmdargs[@]}"; do
		if [ "$i" == "all" ]; then
			local all=1
			break;
		fi
	done

	case "$(uname)" in
		"Darwin")

			#	find needed tools

			IFS=":"

			local brew=NONE
			local rup=NONE	#	rustup
			local compiler=NONE	#	x86_64-elf-gcc also installs x86_64-elf-ld
			local nasm=NONE
			local xorriso=NONE
			
			for i in $PATH; do

				#	find each tool needed for build

				if [ -e "$i/brew" ]; then local brew="$i/brew"; fi
				if [ -e "$i/rustup" ]; then local rup="$i/rustup"; fi
				if [ -e "$i/x86_64-elf-gcc" ]; then local compiler="$i/x86_64-elf-gcc"; fi
				if [ -e "$i/nasm" ]; then local nasm="$i/nasm"; fi
				if [ -e "$i/xorriso" ]; then local xorriso="$i/xorriso"; fi

			done
			

			if [ "$brew" == NONE ]; then

				#	ask to install brew

				warning "HomeBrew is not installed on your system"
				note "HomeBrew is required for automatic installation, however $(yellow "instalation requires running script from internet")"
				read -p "would you like me to install it for you? [y/N]" answer


				answer=$(echo "$answer" | tr '[:upper:]' '[:lower:]')

				echo ans: "'$answer'"

				if [ "$answer" = "y" ]; then
					note "installing HomeBrew"
					output="$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
					if [ "$?" != 0 ]; then
						error "failed to install HomeBrew"
						note "try to install it manually"
						echo command output:
						echo $output
						return 1
					fi
					local brew=brew
				else
					note "HomeBrew installation not permitted"
					note "in order to build OS please install these packages:"
					echo "$(magenta x86_64-elf-gcc) - C cross-compiler"
					echo "$(magenta nasm) - assembler"
					echo "$(magenta rustc) - rust compiler"
					echo "$(magenta qemu) - emulator (optional)"
					return 0
				fi
			fi

			#	install dependencies
			echo
			note "working on dependencies..."

			if [[ "$os_lang" == c && "$compiler" == NONE ]]; then
				note "installing x86_64-elf-gcc"
				output="$($brew install x86_64-elf-gcc)"
				if [ "$?" != 0 ]; then
					error "failed to install x86_64-elf-gcc"
					echo brew output:
					echo $output
					return 1
				fi
				note "x86_64-elf-gcc installed"
				echo
			else
				note "x86_64-elf-gcc is already installed"
			fi

			if [ "$nasm" == NONE ]; then
				note "installing nasm..."
				output="$($brew install nasm)"
				if [ "$?" != 0 ]; then
					error "failed to install nasm"
					echo brew output:
					echo $output
					return 1
				fi
				note "nasm installed"
				echo
			else
				note "nasm is already installed"
			fi

			if [ "$xorriso" == NONE ]; then
				note "installong xorriso"
				output="$($brew install xorriso)"
				if [ "$?" != 0 ]; then
					error "failed to install xorriso"
					echo "output: $output"
					return 1
				fi
			fi

			if [ "$all" -eq 1 ]; then
				if [ "$($brew list | grep qemu)" == "" ]; then
					note "installing qemu..."
					output="$($brew install qemu)"
					if [ "$?" != 0 ]; then
						warning "failed to install qemu"
						echo brew output:
						echo $output
					fi
					note "qemu installed"
				else
					note "qemu already installed"
				fi
			fi


			if [ "$rup" == NONE ]; then

				echo
				warning "rust is not installed on your system"

				if [ "$os_lang" != rust ]; then
					read -p "would you like to skip the installation? [y/N]" answer
					warning "rust is not installed on your system"

					answer=$(echo "$answer" | tr '[:upper:]' '[:lower:]')

					if [ "$answer" = y ]; then
						local rup=SKIP
						note "skipping rust installation..."
					else
						echo
						warning "rust installation requires $(yellow "running script from internet")"
						read -p "would you like me to install it for you? [y/N]" answer

						if [ "$answer" = y ]; then
							note "installing rust"
							curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
							if [ "$?" != 0 ]; then
								error "rust installation failed"
								return 1
							fi
						fi

						export PATH="$PATH:~/.cargo/bin/"
						note "please add the ~/.cargo/bin/ to PATH evironment variable"
						note "rust installation completed"
						local rup="$HOME/.cargo/bin/rustup"
					fi
				else
					echo
					warning "rust installation requires $(yellow "running script from internet")"
					read -p "would you like me to install it for you? [y/N]" answer

					if [ "$answer" = y ]; then
						note "installing rust"
						output="$(bash -c curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh)"
						if [ "$?" != 0 ]; then
							error "rust installation failed"
							echo install script output:
							echo $output
							return 1
						fi
					fi

					export PATH="$PATH:~/.cargo/bin/"
					note "please add the $(red ~/.cargo/bin/) to PATH manually for bash"
					note "rust installation completed"
					local rup="~/.cargo/bin/rustup"
					echo rup: $rup
				fi
			fi

			if [ "$rup" != SKIP ]; then

				output="$($rup target add x86_64-unknown-none)"
				if [ "$?" != 0 ]; then
					error "failed to add x86_64 target"
					echo rustup output:
					echo $output
					return 1
				fi
				note "rust setup completed"

			fi

			note "dependency installation completed"

		;;
		"Linux")
			echo running on Linux
			source /etc/os-release

			case "$ID" in
				"fedora")
					note detected Fedora
				;;
				"ubuntu")
					note detected Ubuntu
				;;
				"archlinux")
					note detected Arch
				;;
				*)
					error "unsupported Linux system ($(blue "$ID")"
				;;
			esac
		;;
	esac
}






function setup() {

	local os_lang="NONE"
	local os_arch="ANY"

	if [ -e $UTIL_CONFIG_FILE ]; then
		touch $UTIL_CONFIG_FILE
	fi

	if [ "$#" == 0 ]; then
		error "no arguments for $(blue $subcmd)"
		return 1
	else
		if [ -e "$UTIL_CONFIG_FILE" ]; then
			echo -e "os_lang=NONE\nos_arch=ANY" > $UTIL_CONFIG_FILE
		fi

		for i in "$@"; do
        	case "$i" in
        	"c")
        		if [ "$os_lang" != "NONE" ]; then
        			error "OS language specified for second time"
        			return 1
        		fi
        		echo setting C as project language
        		local os_lang="c"
        	;;
        	"rust")
				if [ "$os_lang" != "NONE" ]; then
					error "OS language specified for second time"
					return 1
				fi
        		echo setting rust as project language
        		local os_lang="rust"
			;;
			"x86_64")
				if [ "$os_arch" != "ANY" ]; then
					error "OS architecture specified for second time"
					return 1
				fi
				echo setting x86_64 as project architecture
				local os_arch="x86_64"
			;;
			"arm64")
				if [ "$os_arch" != "ANY" ]; then
					error "OS architecture specified for second time"
					return 1
				fi
				echo setting arm64 as project architecture
				local os_arch="arm64"
			;;
			*)
				error "unknown token '$i'"
				subcmdargs=("config")
				help 1
			;;
        	esac
        done

        if [ "$os_lang" == "NONE" ]; then
        	echo "$(red ERROR): language was not specified for $(blue config) subcommand"
        	return 1
        fi

		#	save

		echo "$(yellow "would you like to apply changes?")"
		if [ "$os_lang" == "C" ]; then
			echo "	$(red "sources for rust will be deleted")"
		else
			echo "	$(red "sources for C will be deleted")"
		fi

		read -p "would you like to continue? [Y/n]" answer
        answer=$(echo "$answer" | tr '[:upper:]' '[:lower:]')

        if [[ "$answer" != "y" && "$answer" != "" ]]; then
        	echo "$(yellow "dropping new configuration")"
        	return 0
        fi

        echo "$(yellow "applying new configuration")"
        echo -e "os_lang=$os_lang\nos_arch=$os_arch" > $UTIL_CONFIG_FILE

        #if [ "$os_lang" == "c" ]; then
        #	mv ./kernel/C/* ./kernel/
        #else
        #	mv ./kernel/rust/* ./kernel/
        #fi
        #rm -rf ./kernel/c ./kernel/rust/

	fi

	return 0
}



function info() {
	if [ "${#subcmdargs[@]}" == 0 ]; then
		subcmdargs=("all")
	fi


    if [ -e "$UTIL_CONFIG_FILE" ]; then
    	echo > /dev/null
    else
    	error "project is not configured, use this:"
    	subcmdargs=("config")
    	help 1
    fi

    source $UTIL_CONFIG_FILE
    if [ "$os_lang" == "NONE" ]; then
    	error "project is not configured, use this:"
    	subcmdargs=("config")
    	help 1
    fi


	case "${subcmdargs[0]}" in
		"os")
			echo "$(green name):		$os_name"
			echo "$(blue version):	$os_version"
			echo "$(magenta release):	$os_release"
			if [ "$os_arch" == "ANY" ]; then
				echo "$(cyan arch):	x86_64, arm64"
			else
				echo "$(cyan arch):		$os_arch"
			fi
			echo "$(yellow lang):		$os_lang"
		;;
		"kernel")
			local kernel_name="$(cat ./kernel/name)"
			local kernel_version="$(cat ./kernel/version)"

			local files=$(find ./kernel/ -type f \( -name "*.c" -o -name "*.h" -o -name "*.asm" \))

			local lines=0
			for file in $files; do
              # Get the line count for the current file
              local ln=$(wc -l < "$file")

              # Add the line count of this file to the total count
              local lines=$((lines + ln))
            done
            local filecount="$(echo "$files" | wc -l)"

			echo "$(green name):		$kernel_name"
			echo "$(blue version):	$kernel_version"
			echo "$(magenta arch):		$os_arch"
			echo "$(cyan lang):		$os_lang"
			echo "$(yellow lines):		$lines"
			echo "$(red files):		$filecount"
		;;
		"all")
			echo "OS"
			echo "	$(green name):		$os_name"
            echo "	$(blue version):	$os_version"
            echo "	$(magenta release):	$os_release"
            if [ "$os_arch" == "ANY" ]; then
            	echo "	$(cyan arch):	x86_64, arm64"
            else
            	echo "	$(cyan arch):		$os_arch"
            fi
            echo "	$(yellow lang):		$os_lang"




            local kernel_name="$(cat ./kernel/name)"
            local kernel_version="$(cat ./kernel/version)"

            local files=$(find ./kernel/ -type f \( -name "*.c" -o -name "*.h" -o -name "*.asm" \))

            local lines=0
            for file in $files; do
            	# Get the line count for the current file
                local ln=$(wc -l < "$file")

                # Add the line count of this file to the total count
                local lines=$((lines + ln))
            done
            local filecount="$(echo "$files" | wc -l)"

            echo "kernel"
            echo "	$(green name):		$kernel_name"
            echo "	$(blue version):	$kernel_version"
            echo "	$(magenta lines):		$lines"
			echo "	$(cyan files):		$filecount"
		;;
		*)
			error "unknown token '${subcmdargs[0]}'"
			return 1
		;;
	esac
}






function help() {

	if [ "${#subcmdargs[@]}" == 0 ]; then
		echo "$(green $0) is simple script used to build and manage project"
		echo "	$(magenta NOTE): this script should always be run in project root directory"
		echo; echo
		echo "$(green $0) $(blue info) - show information about project"
		echo "$(green $0) $(blue setup) - setup the project"
		echo "$(green $0) $(blue build) - build OS"
		echo "$(green $0) $(red test) - run tests"
		echo "$(green $0) $(blue run) - run OS in emulator"
		echo "$(green $0) $(red dependencies) - manage build dependencies on supported distributions"
		echo "$(green $0) $(red change) - change project information or configuration"

		echo
		echo "$(green $0) $(blue help) - show help page"
		echo "	append '$(blue "<subcommand>")' to show more info about commands"
		echo "	or append '$(blue all)' to show info about all subcommands"
	else
		if [ "${subcmdargs[0]}" == "all" ]; then
			subcmdargs=("info" "config" "build" "test" "run" "dependencies" "change")
		fi
	fi

	IFS=" "
	for i in "${subcmdargs[@]}"; do
		case $i in
			"info")
				echo "$(green $0) $(blue $i)"
				echo "	$(yellow 'prints info about the project')"
				echo "	$(green "$0 info") $(blue os) prints info about the OS"
				echo "	$(green "$0 info") $(blue kernel) info about the kernel"
			;;
			"setup")
				echo "$(green $0) $(blue $i)"
				echo "	$(yellow 'configures project for specific language and/or architecture')"
				echo "	$(green $0 config) $(blue "<lang> <arch>")"
				echo "		languages: $(green c), $(red rust) (only C is currently implemented)"
				echo "		architectures: $(green x86_64), $(red arm64) (only x86_64 is currently implemented)"
			;;
			"build")
				echo "$(green $0) $(blue $i)"
				echo "	$(yellow 'builds the OS')"
				echo "	$(blue debug) builds the OS with debug options"
				echo "	'$(blue run)' to run the OS in emulator"
				echo "		'$(blue dbg)' to attach debugger to the emulator"
				echo "	'$(blue --)' to pass additional information to the compiler"
				echo "		for more info use $(green "$0 help") $(blue compiler)"
			;;
			"test")
				echo "$(green $0) $(blue $i)"
				echo "	$(yellow 'run tests') $(red "(rust only) (not implemented yet)")"
			;;
			"run")
				echo "$(green $0) $(blue $i)"
				echo "	$(yellow 'runs the OS in emulator')"
				echo "	'$(blue dbg)' to attach debugger"
			;;
			"change")
				echo "$(green $0) $(blue $i)"
				echo "	$(yellow 'change project information or configuration')"
				echo "		$(blue OS) $(magenta name) $(cyan "<name>") - changes OS name in all configurations and files"
				echo "		$(blue OS) $(magenta version) $(cyan "<version>") - changes OS version"
				echo "		$(blue OS) $(magenta release) $(cyan "<release>") - changes OS release"

				echo
				echo "		$(blue kernel) $(magenta name) $(cyan "<name>")		- changes kernel name"
				echo "		$(blue kernel) $(magenta version) $(cyan "<version>")	- changes kernel version"
			;;
			"dependencies")
				echo "$(green $0) $(blue $i)"
				echo "	$(yellow 'manage build dependencies on supported systems')"
				echo "	$(blue install) - install required dependencies"
				echo "		$(blue "all") - installs optional dependencies (emulator, debugger, etc.)"
			;;
			*)
				echo "$(yellow "unknown subcommand") '$(blue $i)'"
				subcmdargs=()
				help 1
			;;
		esac
		if [ -e "./tmp/kernel/" ]; then
			echo > /dev/null
		else
			mkdir -p ./tmp/kernel/
		fi
		echo
	done
	exit $1
}













#	SCRIPT ENTRY POINT

if [ "$#" -eq 0 ]; then
	echo "$(red ERROR): no subcommand given"
	echo
	help
fi

output=""



if  [ -e "$UTIL_CONFIG_FILE" ]; then
	source $UTIL_CONFIG_FILE
else
	if [ "$1" != "setup" ]; then
		error "could not find project configuration file, please run $(green $0) $(blue setup) to configure project"
		exit 1
	fi
fi

if [ -e "$OS_RELEASE_FILE" ]; then
	source $OS_RELEASE_FILE
else
	warning "configuration file ($OS_RELEASE_FILE) was not found -> running with defaults"
	os_name=baseOS
	os_release=baseOS-0.0.1
	os_version=0.0.1
fi

if [ -e "./kernel/$os_lang" ]; then
	path="./kernel/$os_lang"
	go_back="../../"
else
	path="./kernel"
	go_back="../"
fi



echo 

subcmdargs=(${@:2})
case $1 in
	"help") help 0;;
	"-h") help 0;;
	"--help") help 0;;
	"info")
		subcmd="info"
		info "${subcmdargs[@]}"
	;;
	"run")
		run
	;;
	"build")
		subcmd="build"
		build "${subcmdargs[@]}"
	;;
	"test")
		subcmd="test"
		test "${subcmdargs[@]}"
	;;
	"setup")
		subcmd="setup"
		setup "${subcmdargs[@]}"
	;;
	"dependencies")
		subcmd="dependencies"
		dependencies
	;;
	"dep")
		subcmd="dependencies"
		dependencies
	;;
	*)
		echo "$(red ERROR): unknown subcommand $i"
		help 1
	;;
esac

if [[ "$?" != 0 ]]; then
	echo "$(red ERROR): subcommand '$subcmd' failed"
	exit 1
fi


# TODO
#	rewrite
#		configure will choose tools
#		reconfigure will check the tools and posibly reconfigure the project
#		tools in config file

#		split into multiple scripts: ./files/base/scripts/*